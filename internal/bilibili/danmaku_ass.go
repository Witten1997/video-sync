package bilibili

import (
	"fmt"
	"math"
	"sort"
	"strings"

	"bili-download/internal/config"
)

// ASSConverter 弹幕转ASS字幕转换器
type ASSConverter struct {
	config   *config.DanmakuConfig
	width    int // 视频宽度
	height   int // 视频高度
	duration int // 视频时长(秒)
}

// NewASSConverter 创建ASS转换器
func NewASSConverter(cfg *config.DanmakuConfig, width, height, duration int) *ASSConverter {
	// 如果未提供尺寸，使用默认值
	if width == 0 {
		width = 1920
	}
	if height == 0 {
		height = 1080
	}
	if duration == 0 {
		duration = 600 // 默认10分钟
	}

	return &ASSConverter{
		config:   cfg,
		width:    width,
		height:   height,
		duration: duration,
	}
}

// ConvertToASS 将弹幕列表转换为ASS格式字符串
func (c *ASSConverter) ConvertToASS(danmakus []DanmakuElem) string {
	var sb strings.Builder

	// 写入ASS文件头
	c.writeHeader(&sb)

	// 写入样式定义
	c.writeStyles(&sb)

	// 写入事件部分
	c.writeEvents(&sb, danmakus)

	return sb.String()
}

// writeHeader 写入ASS文件头
func (c *ASSConverter) writeHeader(sb *strings.Builder) {
	sb.WriteString("[Script Info]\n")
	sb.WriteString("; Script generated by bili-download\n")
	sb.WriteString("Title: Bilibili Danmaku\n")
	sb.WriteString("ScriptType: v4.00+\n")
	sb.WriteString(fmt.Sprintf("PlayResX: %d\n", c.width))
	sb.WriteString(fmt.Sprintf("PlayResY: %d\n", c.height))
	sb.WriteString("WrapStyle: 2\n")
	sb.WriteString("ScaledBorderAndShadow: yes\n")
	sb.WriteString("YCbCr Matrix: TV.709\n")
	sb.WriteString("\n")
}

// writeStyles 写入样式定义
func (c *ASSConverter) writeStyles(sb *strings.Builder) {
	sb.WriteString("[V4+ Styles]\n")
	sb.WriteString("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")

	// 默认样式
	bold := 0
	if c.config.Bold {
		bold = -1
	}
	// 透明度：ASS中0=完全不透明，255=完全透明
	// 配置中opacity: 0-255，0=完全透明，255=完全不透明
	// 所以ASS alpha = 255 - config.Opacity
	alphaValue := 255 - c.config.Opacity

	// 获取主要颜色（如果启用强制自定义颜色，使用自定义颜色，否则使用白色）
	var primaryColor string
	if c.config.ForceCustomColor && c.config.CustomColor != "" {
		// 使用 parseCustomColor 统一解析颜色（支持 #RRGGBB 和 rgb() 格式）
		colorWithSymbols := c.parseCustomColor(c.config.CustomColor)
		// 去掉前后的 & 符号，只保留颜色值（如 HFFFF00）
		// 使用 TrimPrefix 和 TrimSuffix 而不是 Trim，避免删除中间的字符
		primaryColor = strings.TrimPrefix(colorWithSymbols, "&")
		primaryColor = strings.TrimSuffix(primaryColor, "&")
		// 再去掉开头的 H（因为样式定义中会自动加上 &H）
		primaryColor = strings.TrimPrefix(primaryColor, "H")
	} else {
		primaryColor = "FFFFFF" // 默认白色
	}

	// 描边宽度（放大1.5倍以增强清晰度）
	outlineWidth := c.config.OutlineWidth
	if outlineWidth < 2 {
		outlineWidth = 2 // 至少2像素描边
	}

	// 阴影深度（增强边缘清晰度）
	shadowDepth := 1.5
	if c.config.OutlineWidth > 2 {
		shadowDepth = 2.0
	}

	// ASS格式：
	// PrimaryColour: 主要文字颜色 &HAABBGGRR (AA=alpha, BB=blue, GG=green, RR=red)
	// SecondaryColour: 次要颜色（卡拉OK效果用）
	// OutlineColour: 描边颜色（黑色，完全不透明）
	// BackColour: 阴影颜色（黑色，半透明）
	sb.WriteString(fmt.Sprintf("Style: Default,%s,%d,&H%02X%s,&H%02X%s,&H00000000,&H80000000,%d,0,0,0,100,100,0,0,1,%.1f,%.1f,2,0,0,0,1\n",
		c.config.FontName, // 字体名称
		c.config.FontSize, // 字体大小
		alphaValue,        // 主要颜色透明度
		primaryColor,      // 主要颜色BGR
		alphaValue,        // 次要颜色透明度
		primaryColor,      // 次要颜色BGR
		bold,              // 粗体
		outlineWidth,      // 描边宽度
		shadowDepth,       // 阴影深度
	))
	sb.WriteString("\n")
}

// writeEvents 写入弹幕事件
func (c *ASSConverter) writeEvents(sb *strings.Builder, danmakus []DanmakuElem) {
	sb.WriteString("[Events]\n")
	sb.WriteString("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

	// 按时间排序弹幕
	sortedDanmakus := make([]DanmakuElem, len(danmakus))
	copy(sortedDanmakus, danmakus)
	sort.Slice(sortedDanmakus, func(i, j int) bool {
		return sortedDanmakus[i].Progress < sortedDanmakus[j].Progress
	})

	// 轨道管理器
	scrollTracks := NewTrackManager(c.getScrollTrackCount())
	topTracks := NewTrackManager(c.getTopTrackCount())
	bottomTracks := NewTrackManager(c.getBottomTrackCount())

	// 转换每条弹幕
	for _, dm := range sortedDanmakus {
		if dm.Content == "" {
			continue
		}

		startTime := float64(dm.Progress)/1000.0 + c.config.TimeOffset
		if startTime < 0 {
			startTime = 0
		}

		// 根据弹幕类型选择轨道
		var track int
		var endTime float64
		var text string

		switch dm.Mode {
		case 1, 2, 3: // 滚动弹幕
			track = scrollTracks.AllocateTrack(startTime)
			endTime = startTime + c.config.Duration
			text = c.formatScrollingDanmaku(dm, track)

		case 4: // 底部弹幕
			endTime = startTime + 4.0 // 底部弹幕固定显示4秒
			track = bottomTracks.AllocateTrack(startTime)
			text = c.formatBottomDanmaku(dm, track)

		case 5: // 顶部弹幕
			endTime = startTime + 4.0 // 顶部弹幕固定显示4秒
			track = topTracks.AllocateTrack(startTime)
			text = c.formatTopDanmaku(dm, track)

		default: // 其他类型暂不支持
			continue
		}

		// 写入Dialogue行
		sb.WriteString(fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,%s\n",
			c.formatTime(startTime),
			c.formatTime(endTime),
			text,
		))

		// 更新轨道占用时间
		switch dm.Mode {
		case 1, 2, 3:
			scrollTracks.ReleaseTrack(track, endTime)
		case 4:
			bottomTracks.ReleaseTrack(track, endTime)
		case 5:
			topTracks.ReleaseTrack(track, endTime)
		}
	}
}

// formatScrollingDanmaku 格式化滚动弹幕
func (c *ASSConverter) formatScrollingDanmaku(dm DanmakuElem, track int) string {
	// 计算Y坐标
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	y := track*laneSize + c.config.FontSize

	// 计算移动距离
	textWidth := c.estimateTextWidth(dm.Content)
	startX := c.width + textWidth/2
	endX := -textWidth / 2

	// 生成移动效果
	// 如果启用了强制自定义颜色，不需要单独设置颜色（样式中已设置）
	if c.config.ForceCustomColor {
		return fmt.Sprintf("{\\move(%d,%d,%d,%d)}%s",
			startX, y, endX, y, c.escapeText(dm.Content))
	}
	// 否则使用弹幕原始颜色
	color := c.getColor(dm.Color)
	return fmt.Sprintf("{\\move(%d,%d,%d,%d)\\c%s}%s",
		startX, y, endX, y, color, c.escapeText(dm.Content))
}

// formatBottomDanmaku 格式化底部弹幕
func (c *ASSConverter) formatBottomDanmaku(dm DanmakuElem, track int) string {
	// 计算Y坐标（从底部向上）
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	bottomHeight := int(float64(c.height) * c.config.BottomPercentage)
	y := c.height - bottomHeight + track*laneSize + c.config.FontSize

	// 居中显示
	// 如果启用了强制自定义颜色，不需要单独设置颜色（样式中已设置）
	if c.config.ForceCustomColor {
		return fmt.Sprintf("{\\an2\\pos(%d,%d)}%s",
			c.width/2, y, c.escapeText(dm.Content))
	}
	// 否则使用弹幕原始颜色
	color := c.getColor(dm.Color)
	return fmt.Sprintf("{\\an2\\pos(%d,%d)\\c%s}%s",
		c.width/2, y, color, c.escapeText(dm.Content))
}

// formatTopDanmaku 格式化顶部弹幕
func (c *ASSConverter) formatTopDanmaku(dm DanmakuElem, track int) string {
	// 计算Y坐标（从顶部向下）
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	y := track*laneSize + c.config.FontSize

	// 居中显示
	// 如果启用了强制自定义颜色，不需要单独设置颜色（样式中已设置）
	if c.config.ForceCustomColor {
		return fmt.Sprintf("{\\an8\\pos(%d,%d)}%s",
			c.width/2, y, c.escapeText(dm.Content))
	}
	// 否则使用弹幕原始颜色
	color := c.getColor(dm.Color)
	return fmt.Sprintf("{\\an8\\pos(%d,%d)\\c%s}%s",
		c.width/2, y, color, c.escapeText(dm.Content))
}

// getScrollTrackCount 获取滚动弹幕轨道数
func (c *ASSConverter) getScrollTrackCount() int {
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	availableHeight := int(float64(c.height) * c.config.FloatPercentage)
	return availableHeight / laneSize
}

// getTopTrackCount 获取顶部弹幕轨道数
func (c *ASSConverter) getTopTrackCount() int {
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	return c.height / laneSize / 4 // 顶部使用屏幕的1/4
}

// getBottomTrackCount 获取底部弹幕轨道数
func (c *ASSConverter) getBottomTrackCount() int {
	laneSize := c.config.LaneSize
	if laneSize == 0 {
		laneSize = c.config.FontSize + 4
	}
	bottomHeight := int(float64(c.height) * c.config.BottomPercentage)
	return bottomHeight / laneSize
}

// estimateTextWidth 估算文本宽度
func (c *ASSConverter) estimateTextWidth(text string) int {
	// 简单估算：中文字符按字体大小计算，英文字符按字体大小的一半计算
	width := 0
	for _, r := range text {
		if r < 128 {
			width += c.config.FontSize / 2
		} else {
			width += c.config.FontSize
		}
	}
	return int(float64(width) * c.config.WidthRatio)
}

// formatColor 格式化颜色为ASS格式
func (c *ASSConverter) formatColor(color uint32) string {
	// 将RGB转换为BGR（ASS使用BGR顺序）
	r := (color >> 16) & 0xFF
	g := (color >> 8) & 0xFF
	b := color & 0xFF
	return fmt.Sprintf("&H%02X%02X%02X&", b, g, r)
}

// getColor 获取弹幕颜色（根据配置决定使用自定义颜色还是原始颜色）
func (c *ASSConverter) getColor(originalColor uint32) string {
	// 如果启用了强制自定义颜色
	if c.config.ForceCustomColor && c.config.CustomColor != "" {
		return c.parseCustomColor(c.config.CustomColor)
	}
	// 否则使用弹幕原始颜色
	return c.formatColor(originalColor)
}

// parseCustomColor 解析自定义颜色（支持 #RRGGBB 和 rgb(r,g,b) 格式）
func (c *ASSConverter) parseCustomColor(colorStr string) string {
	colorStr = strings.TrimSpace(colorStr)

	// 支持 rgb(r, g, b) 格式
	if strings.HasPrefix(colorStr, "rgb(") && strings.HasSuffix(colorStr, ")") {
		// 提取括号内的内容
		rgbContent := colorStr[4 : len(colorStr)-1]
		// 分割成 r, g, b
		parts := strings.Split(rgbContent, ",")
		if len(parts) == 3 {
			var r, g, b int
			// 使用 int 而不是 uint32，然后转换
			fmt.Sscanf(strings.TrimSpace(parts[0]), "%d", &r)
			fmt.Sscanf(strings.TrimSpace(parts[1]), "%d", &g)
			fmt.Sscanf(strings.TrimSpace(parts[2]), "%d", &b)

			// 转换为 ASS 的 BGR 格式
			// ASS格式：&HAABBGGRR，所以顺序是 B G R
			result := fmt.Sprintf("&H%02X%02X%02X&", b, g, r)
			// 调试日志
			fmt.Printf("[DEBUG] 解析颜色: %s -> R=%d G=%d B=%d -> ASS=%s\n", colorStr, r, g, b, result)
			return result
		}
	}

	// 支持 #RRGGBB 格式
	colorStr = strings.TrimPrefix(colorStr, "#")
	if len(colorStr) == 6 {
		// 解析 RGB
		var r, g, b int
		fmt.Sscanf(colorStr, "%02x%02x%02x", &r, &g, &b)
		// 转换为 ASS 的 BGR 格式
		result := fmt.Sprintf("&H%02X%02X%02X&", b, g, r)
		// 调试日志
		fmt.Printf("[DEBUG] 解析颜色: #%s -> R=%d G=%d B=%d -> ASS=%s\n", colorStr, r, g, b, result)
		return result
	}

	// 如果解析失败，返回白色
	return "&HFFFFFF&"
}

// formatTime 格式化时间为ASS格式 (h:mm:ss.cc)
func (c *ASSConverter) formatTime(seconds float64) string {
	hours := int(seconds) / 3600
	minutes := (int(seconds) % 3600) / 60
	secs := int(seconds) % 60
	centisecs := int((seconds - float64(int(seconds))) * 100)
	return fmt.Sprintf("%d:%02d:%02d.%02d", hours, minutes, secs, centisecs)
}

// escapeText 转义ASS文本中的特殊字符
func (c *ASSConverter) escapeText(text string) string {
	// ASS中需要转义的字符
	text = strings.ReplaceAll(text, "\\", "\\\\")
	text = strings.ReplaceAll(text, "{", "\\{")
	text = strings.ReplaceAll(text, "}", "\\}")
	text = strings.ReplaceAll(text, "\n", "\\N")
	return text
}

// TrackManager 轨道管理器
type TrackManager struct {
	tracks     []float64 // 每个轨道下次可用的时间
	trackCount int
}

// NewTrackManager 创建轨道管理器
func NewTrackManager(trackCount int) *TrackManager {
	if trackCount < 1 {
		trackCount = 1
	}
	return &TrackManager{
		tracks:     make([]float64, trackCount),
		trackCount: trackCount,
	}
}

// AllocateTrack 分配一个可用轨道
func (tm *TrackManager) AllocateTrack(currentTime float64) int {
	// 找到最早可用的轨道
	minTrack := 0
	minTime := tm.tracks[0]

	for i := 1; i < tm.trackCount; i++ {
		if tm.tracks[i] < minTime {
			minTime = tm.tracks[i]
			minTrack = i
		}
	}

	return minTrack
}

// ReleaseTrack 释放轨道（设置下次可用时间）
func (tm *TrackManager) ReleaseTrack(track int, releaseTime float64) {
	if track >= 0 && track < tm.trackCount {
		tm.tracks[track] = math.Max(tm.tracks[track], releaseTime)
	}
}
